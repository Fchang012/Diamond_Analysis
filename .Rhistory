CM <- table(test_pred, test_SVM$Above.Median)
print("Confusion Matrix Test Linear K")
#Built in Confusion matrix
confusionMatrix(test_pred, test_SVM$Above.Median)
#incorrect classification
print(paste("Overall Wrong Test: ", 1-sum(diag(CM))/sum(CM)) )
#Tuning
#We can also do some customizations for selecting C value(Cost) in Linear classifier. This can be done by inputting values in grid search.  The next code snippet will show you, building & tuning of an SVM classifier with different values of C. We are going to put some values of C using expand.grid() into "grid" dataframe. Next step is to use this dataframe for testing our classifier at specific C values. It needs to be put in train() method with tuneGrid parameter.
# Setup for cross validation
trctrl <- trainControl(method = "repeatedcv",
number = 10,
repeats = 3)
# grid <- expand.grid(C = c(0,0.01, 0.05, 0.1, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 5, 10))
grid <- expand.grid(C = seq(0, 3, 0.01))
svm_Linear_Grid <- train(f, data = train_SVM, method = "svmLinear",
trControl=trctrl,
tuneLength = 10,
tuneGrid = grid)
plot(svm_Linear_Grid)
test_pred_grid <- predict(svm_Linear_Grid, newdata = test_SVM)
CM <- table(test_pred_grid, test_SVM$Above.Median)
print("Confusion Matrix Linear K")
#Built in Confusion matrix
confusionMatrix(test_pred_grid, test_SVM$Above.Median)
#incorrect classification
print(paste("Overall Wrong Test: ", 1-sum(diag(CM))/sum(CM)) )
saveRDS(svm_Radial_Grid, "./SVM_Model/svm_Linear_Grid")
saveRDS(svm_Linear_Grid, "./SVM_Model/svm_Linear_Grid")
library(plyr)
library(stringr)
# library(zipcode)
library(dummies)
require(PerformanceAnalytics)
require(neuralnet)
require(ggplot2)
require(caret)
require(foreach)
require(doParallel)
#Read in data
HospitalDF <- read.csv("Hospital General Information.csv")
KaggleIncomeDF <- read.csv("./US_Household_Income_Statistics/kaggle_income.csv")
#Remove 0 Median Income
KaggleIncomeDF <- KaggleIncomeDF[!KaggleIncomeDF$Median == 0,]
#Find the Average Median by Zipcode
KaggleIncomeDF <- aggregate(KaggleIncomeDF$Median, by=list(KaggleIncomeDF$Zip_Code), na.rm = TRUE, FUN=mean)
names(KaggleIncomeDF) <- c("Zip_Code", "Median.Income")
#Tack on Median income data by zipcode
HospitalDF <- merge(HospitalDF, KaggleIncomeDF, by.x = "ZIP.Code", by.y = "Zip_Code")
# #Clean zipcodes
# HospitalDF$ZIP.Code <- lapply(HospitalDF$ZIP.Code, clean.zipcodes)
# HospitalDF$ZIP.Code <- as.character(HospitalDF$ZIP.Code)
# #Debugging
# HospitalDF_Check <- HospitalDF
#Remove sites with no overall ratings
HospitalDF <- HospitalDF[!HospitalDF$Hospital.overall.rating == "Not Available",]
#Change into buckets of Below 3 (below average) and 3-5 (Average and above)
HospitalDF$Hospital.overall.rating <- as.numeric(HospitalDF$Hospital.overall.rating)
HospitalDF[HospitalDF$Hospital.overall.rating < 3,]$Hospital.overall.rating <- 0
HospitalDF[HospitalDF$Hospital.overall.rating >= 3,]$Hospital.overall.rating <- 1
# #Debugging
# HospitalDF_Check <- HospitalDF_Check[!HospitalDF_Check$Hospital.overall.rating == "Not Available",]
# names(HospitalDF)
#Remove footnotes
drops <- c("ZIP.Code",
"Hospital.Name",
"Address",
"City",
"Phone.Number",
"Hospital.overall.rating.footnote",
"Mortality.national.comparison.footnote",
"Safety.of.care.national.comparison.footnote",
"Readmission.national.comparison.footnote",
"Patient.experience.national.comparison.footnote",
"Effectiveness.of.care.national.comparison.footnote",
"Timeliness.of.care.national.comparison.footnote",
"Efficient.use.of.medical.imaging.national.comparison.footnote")
HospitalDF <- HospitalDF[, !(names(HospitalDF) %in% drops)]
# #Debugging
# HospitalDF_Check <- HospitalDF_Check[, !(names(HospitalDF_Check) %in% drops)]
#Dynamic Variable Nameing
dynName <- function(theName, theData){
#Make dictionaries for the column
assign(paste(str_trim(theName),".dict", sep = ""), levels(theData), envir = .GlobalEnv)
#Convert to numeric
return(as.numeric(theData))
}
#Translate Back
translateBack <- function(theDict, theData){
return(as.factor(theDict[theData]))
}
#Turning Factors to Numerics
#  [2] "City"
# HospitalDF$City <- dynName("City", HospitalDF$City)
# #Debugging
# #Translate back
# HospitalDF$City <- translateBack(City.dict, HospitalDF$City)
#  [3] "State"
HospitalDF$State <- dynName("State", HospitalDF$State)
# #Debugging
# #Translate back
# HospitalDF$State <- translateBack(State.dict, HospitalDF$State)
#  [4] "ZIP.Code"
#  [5] "County.Name"
HospitalDF$County.Name <- dynName("County.Name", HospitalDF$County.Name)
# # #Debugging
# #Translate back
# HospitalDF$County.Name <- translateBack(County.Name.dict, HospitalDF$County.Name)
#  [6] "Hospital.Type"
# HospitalDF$Hospital.Type <- dynName("Hospital.Type", HospitalDF$Hospital.Type)
# #Debugging
# #Translate back
# HospitalDF$Hospital.Type <- translateBack(Hospital.Type.dict, HospitalDF$Hospital.Type)
#  [7] "Hospital.Ownership"
# HospitalDF$Hospital.Ownership <- dynName("Hospital.Ownership", HospitalDF$Hospital.Ownership)
# #Debugging
# #Translate back
# HospitalDF$Hospital.Ownership <- translateBack(Hospital.Ownership.dict, HospitalDF$Hospital.Ownership)
#  [8] "Emergency.Services"
HospitalDF$Emergency.Services <- dynName("Emergency.Services", HospitalDF$Emergency.Services)
# #Debugging
# #Translate back
# HospitalDF$Emergency.Services <- translateBack(Emergency.Services.dict, HospitalDF$Emergency.Services)
#  [9] "Meets.criteria.for.meaningful.use.of.EHRs"
# HospitalDF$Meets.criteria.for.meaningful.use.of.EHRs <- dynName("Meets.criteria.for.meaningful.use.of.EHRs", HospitalDF$Meets.criteria.for.meaningful.use.of.EHRs)
# #Debugging
# #Translate back
# HospitalDF$Meets.criteria.for.meaningful.use.of.EHRs <- translateBack(Meets.criteria.for.meaningful.use.of.EHRs.dict, HospitalDF$Meets.criteria.for.meaningful.use.of.EHRs)
# [10] "Hospital.overall.rating" <- Trying to predict
# [11] "Mortality.national.comparison"
#Remove Not Available
HospitalDF <- HospitalDF[!HospitalDF$Mortality.national.comparison ==  levels(HospitalDF$Mortality.national.comparison)[3],]
# HospitalDF$Mortality.national.comparison <- dynName("Mortality.national.comparison", HospitalDF$Mortality.national.comparison)
# #Debugging
# #Translate back
# HospitalDF$Mortality.national.comparison <- translateBack(Mortality.national.comparison.dict, HospitalDF$Mortality.national.comparison)
# [12] "Safety.of.care.national.comparison"
#Remove Not Available
HospitalDF <- HospitalDF[!HospitalDF$Safety.of.care.national.comparison == levels(HospitalDF$Safety.of.care.national.comparison)[3],]
# HospitalDF$Safety.of.care.national.comparison <- dynName("Safety.of.care.national.comparison", HospitalDF$Safety.of.care.national.comparison)
# #Debugging
# #Translate back
# HospitalDF$Safety.of.care.national.comparison <- translateBack(Safety.of.care.national.comparison.dict, HospitalDF$Safety.of.care.national.comparison)
# [13] "Readmission.national.comparison"
# HospitalDF$Readmission.national.comparison <- dynName("Readmission.national.comparison", HospitalDF$Readmission.national.comparison)
# #Debugging
# #Translate back
# HospitalDF$Readmission.national.comparison <- translateBack(Readmission.national.comparison.dict, HospitalDF$Readmission.national.comparison)
# [14] "Patient.experience.national.comparison"
#Remove Not Available
HospitalDF <- HospitalDF[!HospitalDF$Patient.experience.national.comparison == levels(HospitalDF$Patient.experience.national.comparison)[3],]
# HospitalDF$Patient.experience.national.comparison <- dynName("Patient.experience.national.comparison", HospitalDF$Patient.experience.national.comparison)
# #Debugging
# #Translate back
# HospitalDF$Patient.experience.national.comparison <- translateBack(Patient.experience.national.comparison.dict, HospitalDF$Patient.experience.national.comparison)
# [15] "Effectiveness.of.care.national.comparison"
#Remove Not Available
HospitalDF <- HospitalDF[!HospitalDF$Effectiveness.of.care.national.comparison == levels(HospitalDF$Effectiveness.of.care.national.comparison)[3],]
# HospitalDF$Effectiveness.of.care.national.comparison <- dynName("Effectiveness.of.care.national.comparison", HospitalDF$Effectiveness.of.care.national.comparison)
# #Debugging
# #Translate back
# HospitalDF$Effectiveness.of.care.national.comparison <- translateBack(Effectiveness.of.care.national.comparison.dict, HospitalDF$Effectiveness.of.care.national.comparison)
# [16] "Timeliness.of.care.national.comparison"
#Remove Not Available
HospitalDF <- HospitalDF[!HospitalDF$Timeliness.of.care.national.comparison == levels(HospitalDF$Timeliness.of.care.national.comparison)[3], ]
# HospitalDF$Timeliness.of.care.national.comparison <- dynName("Timeliness.of.care.national.comparison", HospitalDF$Timeliness.of.care.national.comparison)
# #Debugging
# #Translate back
# HospitalDF$Timeliness.of.care.national.comparison <- translateBack(Timeliness.of.care.national.comparison.dict, HospitalDF$Timeliness.of.care.national.comparison)
# [17] "Efficient.use.of.medical.imaging.national.comparison"
#Remove Not Available
HospitalDF <- HospitalDF[!HospitalDF$Efficient.use.of.medical.imaging.national.comparison == levels(HospitalDF$Efficient.use.of.medical.imaging.national.comparison)[3], ]
# HospitalDF$Efficient.use.of.medical.imaging.national.comparison <- dynName("Efficient.use.of.medical.imaging.national.comparison", HospitalDF$Efficient.use.of.medical.imaging.national.comparison)
# #Debugging
# #Translate back
# HospitalDF$Efficient.use.of.medical.imaging.national.comparison <- translateBack(Efficient.use.of.medical.imaging.national.comparison.dict, HospitalDF$Efficient.use.of.medical.imaging.national.comparison)
# # #Debugging Comparisons
# debugIndex <- sample(1:length(HospitalDF$Provider.ID), 5, replace=T)
# x <- HospitalDF[debugIndex,]
#
# y <- HospitalDF_Check[HospitalDF_Check$Provider.ID %in% x$Provider.ID, ]
HospitalDF <- HospitalDF[c(1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 8)]
#Clean
HospitalDF <- droplevels(HospitalDF)
#Scale the data between 0-1
scl <- function(x){
(x - min(x)) / (max(x) - min(x))
}
HospitalDF$Median.Income <- scl(HospitalDF$Median.Income)
#75% for sample size
smp_size <- floor(0.75 * nrow(HospitalDF))
#Set the seed to make reproduceable
set.seed(123)
train_ind <- sample(seq_len(nrow(HospitalDF)), size = smp_size)
train <- HospitalDF[train_ind, ]
test <- HospitalDF[-train_ind, ]
#Data Prep
train_SVM <- data.frame(predict(dummyVars("~ .", data=train[,2:15]), newdata = train[,2:15]))
test_SVM <- data.frame(predict(dummyVars("~ .", data=test[,2:15]), newdata = test[,2:15]))
train_SVM <- cbind(train_SVM, train$Hospital.overall.rating)
test_SVM <- cbind(test_SVM, test$Hospital.overall.rating)
colnames(train_SVM)[39] <- "Hospital.overall.rating"
colnames(test_SVM)[39] <- "Hospital.overall.rating"
train_SVM$Hospital.overall.rating <- as.factor(train_SVM$Hospital.overall.rating)
test_SVM$Hospital.overall.rating <- as.factor(test_SVM$Hospital.overall.rating)
#Set up formula
n <- names(train_SVM)
OneHotEncode <- c("Hospital.overall.rating")
f <- as.formula(paste("Hospital.overall.rating ~ ", paste(n[!n %in% "Hospital.overall.rating"], collapse = " + ")))
#Retrieve Model
assign("svm_Linear", readRDS("./SVM_Model/svm_Linear"), envir = .GlobalEnv)
test_pred <- predict(svm_Linear, newdata = test_SVM)
CM <- table(test_pred, test_SVM$Hospital.overall.rating)
print("Confusion Matrix Test Linear K")
#Built in Confusion matrix
confusionMatrix(test_pred, test_SVM$Hospital.overall.rating)
#incorrect classification
print(paste("Overall Wrong Test: ", 1-sum(diag(CM))/sum(CM)) )
#Tuning
#We can also do some customizations for selecting C value(Cost) in Linear classifier. This can be done by inputting values in grid search.  The next code snippet will show you, building & tuning of an SVM classifier with different values of C. We are going to put some values of C using expand.grid() into "grid" dataframe. Next step is to use this dataframe for testing our classifier at specific C values. It needs to be put in train() method with tuneGrid parameter.
# Setup for cross validation
trctrl <- trainControl(method = "repeatedcv",
number = 10,
repeats = 3)
# grid <- expand.grid(C = c(0.5, 0.75, 1, 1.25, 1.5, 1.75, 2,5))
grid <- expand.grid(C = seq(0, 3, 0.01))
svm_Linear_Grid <- train(f, data = train_SVM, method = "svmLinear",
trControl=trctrl,
tuneLength = 10,
tuneGrid = grid)
plot(svm_Linear_Grid)
test_pred_grid <- predict(svm_Linear_Grid, newdata = test_SVM)
CM <- table(test_pred_grid, test_SVM$Hospital.overall.rating)
print("Confusion Matrix Linear K")
#Built in Confusion matrix
confusionMatrix(test_pred_grid, test_SVM$Hospital.overall.rating)
#incorrect classification
print(paste("Overall Wrong Train: ", 1-sum(diag(CM))/sum(CM)) )
saveRDS(svm_Linear_Grid, "./SVM_Model/svm_Linear_Grid")
library(plyr)
library(stringr)
# library(zipcode)
library(dummies)
require(PerformanceAnalytics)
require(neuralnet)
require(ggplot2)
require(caret)
require(foreach)
require(doParallel)
#Read in data
HospitalDF <- read.csv("Hospital General Information.csv")
KaggleIncomeDF <- read.csv("./US_Household_Income_Statistics/kaggle_income.csv")
#Remove 0 Median Income
KaggleIncomeDF <- KaggleIncomeDF[!KaggleIncomeDF$Median == 0,]
#Find the Average Median by Zipcode
KaggleIncomeDF <- aggregate(KaggleIncomeDF$Median, by=list(KaggleIncomeDF$Zip_Code), na.rm = TRUE, FUN=mean)
names(KaggleIncomeDF) <- c("Zip_Code", "Median.Income")
#Tack on Median income data by zipcode
HospitalDF <- merge(HospitalDF, KaggleIncomeDF, by.x = "ZIP.Code", by.y = "Zip_Code")
# #Clean zipcodes
# HospitalDF$ZIP.Code <- lapply(HospitalDF$ZIP.Code, clean.zipcodes)
# HospitalDF$ZIP.Code <- as.character(HospitalDF$ZIP.Code)
# #Debugging
# HospitalDF_Check <- HospitalDF
#Remove sites with no overall ratings
HospitalDF <- HospitalDF[!HospitalDF$Hospital.overall.rating == "Not Available",]
#Change into buckets of Below 3 (below average) and 3-5 (Average and above)
HospitalDF$Hospital.overall.rating <- as.numeric(HospitalDF$Hospital.overall.rating)
HospitalDF[HospitalDF$Hospital.overall.rating < 3,]$Hospital.overall.rating <- 0
HospitalDF[HospitalDF$Hospital.overall.rating >= 3,]$Hospital.overall.rating <- 1
# #Debugging
# HospitalDF_Check <- HospitalDF_Check[!HospitalDF_Check$Hospital.overall.rating == "Not Available",]
# names(HospitalDF)
#Remove footnotes
drops <- c("ZIP.Code",
"Hospital.Name",
"Address",
"City",
"Phone.Number",
"Hospital.overall.rating.footnote",
"Mortality.national.comparison.footnote",
"Safety.of.care.national.comparison.footnote",
"Readmission.national.comparison.footnote",
"Patient.experience.national.comparison.footnote",
"Effectiveness.of.care.national.comparison.footnote",
"Timeliness.of.care.national.comparison.footnote",
"Efficient.use.of.medical.imaging.national.comparison.footnote")
HospitalDF <- HospitalDF[, !(names(HospitalDF) %in% drops)]
# #Debugging
# HospitalDF_Check <- HospitalDF_Check[, !(names(HospitalDF_Check) %in% drops)]
#Dynamic Variable Nameing
dynName <- function(theName, theData){
#Make dictionaries for the column
assign(paste(str_trim(theName),".dict", sep = ""), levels(theData), envir = .GlobalEnv)
#Convert to numeric
return(as.numeric(theData))
}
#Translate Back
translateBack <- function(theDict, theData){
return(as.factor(theDict[theData]))
}
#Turning Factors to Numerics
#  [2] "City"
# HospitalDF$City <- dynName("City", HospitalDF$City)
# #Debugging
# #Translate back
# HospitalDF$City <- translateBack(City.dict, HospitalDF$City)
#  [3] "State"
HospitalDF$State <- dynName("State", HospitalDF$State)
# #Debugging
# #Translate back
# HospitalDF$State <- translateBack(State.dict, HospitalDF$State)
#  [4] "ZIP.Code"
#  [5] "County.Name"
HospitalDF$County.Name <- dynName("County.Name", HospitalDF$County.Name)
# # #Debugging
# #Translate back
# HospitalDF$County.Name <- translateBack(County.Name.dict, HospitalDF$County.Name)
#  [6] "Hospital.Type"
# HospitalDF$Hospital.Type <- dynName("Hospital.Type", HospitalDF$Hospital.Type)
# #Debugging
# #Translate back
# HospitalDF$Hospital.Type <- translateBack(Hospital.Type.dict, HospitalDF$Hospital.Type)
#  [7] "Hospital.Ownership"
# HospitalDF$Hospital.Ownership <- dynName("Hospital.Ownership", HospitalDF$Hospital.Ownership)
# #Debugging
# #Translate back
# HospitalDF$Hospital.Ownership <- translateBack(Hospital.Ownership.dict, HospitalDF$Hospital.Ownership)
#  [8] "Emergency.Services"
HospitalDF$Emergency.Services <- dynName("Emergency.Services", HospitalDF$Emergency.Services)
# #Debugging
# #Translate back
# HospitalDF$Emergency.Services <- translateBack(Emergency.Services.dict, HospitalDF$Emergency.Services)
#  [9] "Meets.criteria.for.meaningful.use.of.EHRs"
# HospitalDF$Meets.criteria.for.meaningful.use.of.EHRs <- dynName("Meets.criteria.for.meaningful.use.of.EHRs", HospitalDF$Meets.criteria.for.meaningful.use.of.EHRs)
# #Debugging
# #Translate back
# HospitalDF$Meets.criteria.for.meaningful.use.of.EHRs <- translateBack(Meets.criteria.for.meaningful.use.of.EHRs.dict, HospitalDF$Meets.criteria.for.meaningful.use.of.EHRs)
# [10] "Hospital.overall.rating" <- Trying to predict
# [11] "Mortality.national.comparison"
#Remove Not Available
HospitalDF <- HospitalDF[!HospitalDF$Mortality.national.comparison ==  levels(HospitalDF$Mortality.national.comparison)[3],]
# HospitalDF$Mortality.national.comparison <- dynName("Mortality.national.comparison", HospitalDF$Mortality.national.comparison)
# #Debugging
# #Translate back
# HospitalDF$Mortality.national.comparison <- translateBack(Mortality.national.comparison.dict, HospitalDF$Mortality.national.comparison)
# [12] "Safety.of.care.national.comparison"
#Remove Not Available
HospitalDF <- HospitalDF[!HospitalDF$Safety.of.care.national.comparison == levels(HospitalDF$Safety.of.care.national.comparison)[3],]
# HospitalDF$Safety.of.care.national.comparison <- dynName("Safety.of.care.national.comparison", HospitalDF$Safety.of.care.national.comparison)
# #Debugging
# #Translate back
# HospitalDF$Safety.of.care.national.comparison <- translateBack(Safety.of.care.national.comparison.dict, HospitalDF$Safety.of.care.national.comparison)
# [13] "Readmission.national.comparison"
# HospitalDF$Readmission.national.comparison <- dynName("Readmission.national.comparison", HospitalDF$Readmission.national.comparison)
# #Debugging
# #Translate back
# HospitalDF$Readmission.national.comparison <- translateBack(Readmission.national.comparison.dict, HospitalDF$Readmission.national.comparison)
# [14] "Patient.experience.national.comparison"
#Remove Not Available
HospitalDF <- HospitalDF[!HospitalDF$Patient.experience.national.comparison == levels(HospitalDF$Patient.experience.national.comparison)[3],]
# HospitalDF$Patient.experience.national.comparison <- dynName("Patient.experience.national.comparison", HospitalDF$Patient.experience.national.comparison)
# #Debugging
# #Translate back
# HospitalDF$Patient.experience.national.comparison <- translateBack(Patient.experience.national.comparison.dict, HospitalDF$Patient.experience.national.comparison)
# [15] "Effectiveness.of.care.national.comparison"
#Remove Not Available
HospitalDF <- HospitalDF[!HospitalDF$Effectiveness.of.care.national.comparison == levels(HospitalDF$Effectiveness.of.care.national.comparison)[3],]
# HospitalDF$Effectiveness.of.care.national.comparison <- dynName("Effectiveness.of.care.national.comparison", HospitalDF$Effectiveness.of.care.national.comparison)
# #Debugging
# #Translate back
# HospitalDF$Effectiveness.of.care.national.comparison <- translateBack(Effectiveness.of.care.national.comparison.dict, HospitalDF$Effectiveness.of.care.national.comparison)
# [16] "Timeliness.of.care.national.comparison"
#Remove Not Available
HospitalDF <- HospitalDF[!HospitalDF$Timeliness.of.care.national.comparison == levels(HospitalDF$Timeliness.of.care.national.comparison)[3], ]
# HospitalDF$Timeliness.of.care.national.comparison <- dynName("Timeliness.of.care.national.comparison", HospitalDF$Timeliness.of.care.national.comparison)
# #Debugging
# #Translate back
# HospitalDF$Timeliness.of.care.national.comparison <- translateBack(Timeliness.of.care.national.comparison.dict, HospitalDF$Timeliness.of.care.national.comparison)
# [17] "Efficient.use.of.medical.imaging.national.comparison"
#Remove Not Available
HospitalDF <- HospitalDF[!HospitalDF$Efficient.use.of.medical.imaging.national.comparison == levels(HospitalDF$Efficient.use.of.medical.imaging.national.comparison)[3], ]
# HospitalDF$Efficient.use.of.medical.imaging.national.comparison <- dynName("Efficient.use.of.medical.imaging.national.comparison", HospitalDF$Efficient.use.of.medical.imaging.national.comparison)
# #Debugging
# #Translate back
# HospitalDF$Efficient.use.of.medical.imaging.national.comparison <- translateBack(Efficient.use.of.medical.imaging.national.comparison.dict, HospitalDF$Efficient.use.of.medical.imaging.national.comparison)
# # #Debugging Comparisons
# debugIndex <- sample(1:length(HospitalDF$Provider.ID), 5, replace=T)
# x <- HospitalDF[debugIndex,]
#
# y <- HospitalDF_Check[HospitalDF_Check$Provider.ID %in% x$Provider.ID, ]
HospitalDF <- HospitalDF[c(1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 8)]
#Clean
HospitalDF <- droplevels(HospitalDF)
#Scale the data between 0-1
scl <- function(x){
(x - min(x)) / (max(x) - min(x))
}
HospitalDF$Median.Income <- scl(HospitalDF$Median.Income)
#75% for sample size
smp_size <- floor(0.75 * nrow(HospitalDF))
#Set the seed to make reproduceable
set.seed(123)
train_ind <- sample(seq_len(nrow(HospitalDF)), size = smp_size)
train <- HospitalDF[train_ind, ]
test <- HospitalDF[-train_ind, ]
#Set the seed to make reproduceable
set.seed(123)
#Get data
shuffle_Train <- HospitalDF[sample(nrow(HospitalDF)),]
shuffle_Train <- subset(shuffle_Train, select = -c(Provider.ID))
#10 qually size folds
folds <- cut(seq(1,nrow(shuffle_Train)), breaks=10, labels=FALSE)
kCrossSVM_RAD <- function(i, shuffle_Train, folds){
testIndexes <- which(folds == i, arr.ind = TRUE)
trainData <- shuffle_Train[-testIndexes, ]
testData <- shuffle_Train[testIndexes, ]
#Data Prep
train_SVM <- data.frame(predict(dummyVars("~ .", data=trainData[,2:15]), newdata = trainData[,2:15]))
test_SVM <- data.frame(predict(dummyVars("~ .", data=testData[,2:15]), newdata = testData[,2:15]))
#Change Hospital.overall.rating to Factor for this to classify
train_SVM[,"Hospital.overall.rating"] <- as.factor(train_SVM[,"Hospital.overall.rating"])
test_SVM[,"Hospital.overall.rating"] <- as.factor(test_SVM[,"Hospital.overall.rating"])
#Set up formula
n <- names(train_SVM)
f <- as.formula(paste("Hospital.overall.rating ~", paste(n[!n %in% "Hospital.overall.rating"], collapse = " + ")))
## SUPPORT VECTOR MACHINE MODEL
# Setup for cross validation
trctrl <- trainControl(method = "repeatedcv",
number = 10,
repeats = 3)
svm_Linear <- train(f, data = train_SVM, method = "svmRadial",
trControl=trctrl,
tuneLength = 10)
test_pred <- predict(svm_Linear, newdata = test_SVM)
CM <- table(test_pred, test_SVM$Hospital.overall.rating)
return(sum(diag(CM))/sum(CM))
}
# Calculate the number of cores
no_cores <- detectCores() - 1
cl<-makeCluster(no_cores)
clusterEvalQ(cl, library(caret))
registerDoParallel(cl)
#Parallel Processing
start <- proc.time()
kCrossValidation <- foreach(i=1:10, .combine = rbind) %dopar% kCrossSVM_RAD(i, shuffle_Train, folds)
validationTime <- proc.time() - start
stopImplicitCluster()
print(paste("Average Result Correct: ", mean(kCrossValidation)))
print("Time:", validationTime[3])
kCrossValidation
mean(kCrossValidation)
install.packages("Quandl")
library(Quandl)
vgt <- Quandl("VGT")
vgt <- Quandl("MSFT")
quantmod
library(quantmod)
getSymbols(c("VGT"))
View(VGT)
source('E:/Shared_Files/Fchang012/Diamond_Analysis/HTML_Table_Parse.R', echo=TRUE)
JamesAllenTable <- as.tibble(JamesAllenTable)
warnings()
View(JamesAllenTable)
View(blueNileDataframe)
blueNileDataframe$Price <- as.double(blueNileDataframe$Price)
View(blueNileDataframe)
source('E:/Shared_Files/Fchang012/Diamond_Analysis/HTML_Table_Parse.R', echo=TRUE)
blueNileDataframe$Price <- as.numeric(gsub('[$,]', '', blueNileDataframe$Price))
View(blueNileDataframe)
blueNileDataframe[1,]$urlList
JamesAllenTable$Price <- as.numeric(gsub('[$,]', '', JamesAllenTable$Price))
JamesAllenTable[1,]$`
Price
`
colnames(JamesAllenTable)
make.names(colnames(JamesAllenTable))
gsub('[.], '', colnames(JamesAllenTable))
)
colnames(JamesAllenTable)
make.name(colnames(JamesAllenTable))
make.names(colnames(JamesAllenTable))
colnames(JamesAllenTable) <- make.names(colnames(JamesAllenTable))
colnames(JamesAllenTable)
?gsub
test <- gsub('.', '', colnames(JamesAllenTable))
test
test <- gsub('.', '', colnames(JamesAllenTable), perl = T)
rwar
test
test <- gsub('.', '', colnames(JamesAllenTable))
colnames(JamesAllenTable)
test <- gsub('[.]', '', colnames(JamesAllenTable))
test
colnames(JamesAllenTable) <- gsub('[.]', '', colnames(JamesAllenTable))
View(JamesAllenTable)
View(JamesAllenTable)
colnames(JamesAllenTable) <- gsub('[X.]', '', colnames(JamesAllenTable))
View(JamesAllenTable)
?xmlToDataFrame
?readHTMLTable
source('E:/Shared_Files/Fchang012/Diamond_Analysis/HTML_Table_Parse.R', echo=TRUE)
View(blueNileDataframe)
source('E:/Shared_Files/Fchang012/Diamond_Analysis/HTML_Table_Parse.R', echo=TRUE)
View(blueNileDataframe)
View(JamesAllenTable)
source('E:/Shared_Files/Fchang012/Diamond_Analysis/HTML_Table_Parse.R', echo=TRUE)
View(JamesAllenTable)
getwd()
source('~/workspace/Fchang012/Diamond_Analysis/HTML_Table_Parse.R', echo=TRUE)
source('~/workspace/Fchang012/Diamond_Analysis/HTML_Table_Parse.R', echo=TRUE)
View(blueNileDataframe)
View(JamesAllenTable)
