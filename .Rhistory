PutToCallRatioOI <- OIPut/OICall
# Options Chain - Calls Out of the Money (NextOptions Expiry Date)
CallOutOfTheMoney <- theOptionChain[[thePeriod]]$calls[theOptionChain[[thePeriod]]$calls$Strike >= getQuote(stockTicker)$Last,]
# Options Chain - Puts Out of The Money (NextOptions Expiry Date)
PutOutOfTheMoney <- theOptionChain[[thePeriod]]$puts[theOptionChain[[thePeriod]]$puts$Strike <= getQuote(stockTicker)$Last,]
# Return the List
theList <- list("HistoricalOptionPriceDF" = HistoricalOptionPriceDF,
"theOptionChain" = theOptionChain,
"CallInTheMoney" = CallInTheMoney,
"PutInTheMoney" = PutInTheMoney,
"VolCall" = VolCall,
"VolPut" = VolPut,
"PutToCallRatioVol" = PutToCallRatioVol,
"OICall" = OICall,
"OIPut" = OIPut,
"PutToCallRatioOI" = PutToCallRatioOI,
"CallOutOfTheMoney" = CallOutOfTheMoney,
"PutOutOfTheMoney" = PutOutOfTheMoney)
return(theList)
}
# After running OptionChain function run this to get call spread with break @ the money
callSpread <- function(theOptionList){
print(theOptionList$CallInTheMoney)
print("------------------------------------------------------------")
print(theOptionList$CallOutOfTheMoney)
}
# After running OptionChain function run this to get put spread with break @ the money
putSpread <- function(theOptionList){
print(theOptionList$PutOutOfTheMoney)
print("------------------------------------------------------------")
print(theOptionList$PutInTheMoney)
}
getSymbols("AMZN")
AMZNOptions <- OptionChain(AMZN)
AMZNOptions <- OptionChain(AMZN,3)
AMZNOptions$PutToCallRatioVol
AMZNOptions$PutToCallRatioOI
callSpread(AMZNOptions)
AMZNOptions$OICall
callSpread(AMZNOptions)
putSpread(AMZNOptions)
sample(1:9,5, replace=T)
sample(1:9,5, replace=T)
sample(1:9,5, replace=T)
sample(1:9,5, replace=T)
sample(1:9,5, replace=T)
require(quantmod)
getSymbols("VGSTX")
x11()
chartSeries("VGSTX")
allReturns(VGSTX, subset="2013::")
VGSTXReturns <- allReturns(VGSTX, subset="2013::")
View(VGSTXReturns)
VGSTXReturns <- allReturns(VGSTX, subset='2013-01-01::')
VGSTXReturns <- dailyReturn(VGSTX, subset = '2013-01-01::')
VGSTXReturns <- monthlyReturn(VGSTX, subset = '2013-01-01::')
chartSeries(VGSTX)
x11()
chartSeries(VGSTX)
VGSTXReturns <- yearlyReturn(VGSTX)
mean(VGSTXReturns)
getSymbols(VGT)
getSymbols("VGT")
VGTReturn <- yearlyReturn(VGT)
View(VGTReturn)
mean(VGTReturn)
VGTReturn <- yearlyReturn(VGT, subset = "2009::")
mean(VGTReturn)
# R Script to get financial data from yahoo and google APIs
# Libraries ---------------------------------------------------------------
require(quantmod)
# Get Stock Info ----------------------------------------------------------
getSymbols(c("SPY",
"BHF",
"COP",
"T",
"MRK"), from=as.Date("16-01-01", format="%y-%m-%d"))
# Options Info ------------------------------------------------------------
# Turning it into a function
OptionChain <- function(stockTickerDF, thePeriod=1){
# get ticker name
stockTicker <- deparse(substitute(stockTickerDF))
# Getting historical options prices
HistoricalOptionPriceDF <- stockTickerDF[options.expiry(stockTickerDF),]
# Get All Option Chains
theOptionChain <- getOptionChain(stockTicker, "2018")
# Options Chain - Calls In the Money (NextOptions Expiry Date)
CallInTheMoney <- theOptionChain[[thePeriod]]$calls[theOptionChain[[thePeriod]]$calls$Strike <= getQuote(stockTicker)$Last,]
# Options Chain - Puts In The Money (NextOptions Expiry Date)
PutInTheMoney <- theOptionChain[[thePeriod]]$puts[theOptionChain[[thePeriod]]$puts$Strike >= getQuote(stockTicker)$Last,]
# Implementation of the Put/Call Ratio (Volume)
# Total vol sum of Call Option / Total vol sum of Put Option
# 1 = Neutral
# > 1 = Bearish
# < 1 = Bullish
VolPut <- sum(theOptionChain[[thePeriod]]$puts$Vol)
VolCall <- sum(theOptionChain[[thePeriod]]$calls$Vol)
PutToCallRatioVol <- VolPut/VolCall
# Implementation of the Put/Call Ratio (Open Interest)
# Total sum OI Call Option / Total sum OI Put Option
# 1 = Neutral
# > 1 = Bearish
# < 1 = Bullish
OIPut <- sum(theOptionChain[[thePeriod]]$puts$OI)
OICall <- sum(theOptionChain[[thePeriod]]$calls$OI)
PutToCallRatioOI <- OIPut/OICall
# Options Chain - Calls Out of the Money (NextOptions Expiry Date)
CallOutOfTheMoney <- theOptionChain[[thePeriod]]$calls[theOptionChain[[thePeriod]]$calls$Strike >= getQuote(stockTicker)$Last,]
# Options Chain - Puts Out of The Money (NextOptions Expiry Date)
PutOutOfTheMoney <- theOptionChain[[thePeriod]]$puts[theOptionChain[[thePeriod]]$puts$Strike <= getQuote(stockTicker)$Last,]
# Return the List
theList <- list("HistoricalOptionPriceDF" = HistoricalOptionPriceDF,
"theOptionChain" = theOptionChain,
"CallInTheMoney" = CallInTheMoney,
"PutInTheMoney" = PutInTheMoney,
"VolCall" = VolCall,
"VolPut" = VolPut,
"PutToCallRatioVol" = PutToCallRatioVol,
"OICall" = OICall,
"OIPut" = OIPut,
"PutToCallRatioOI" = PutToCallRatioOI,
"CallOutOfTheMoney" = CallOutOfTheMoney,
"PutOutOfTheMoney" = PutOutOfTheMoney)
return(theList)
}
# After running OptionChain function run this to get call spread with break @ the money
callSpread <- function(theOptionList){
print(theOptionList$CallInTheMoney)
print("------------------------------------------------------------")
print(theOptionList$CallOutOfTheMoney)
}
# After running OptionChain function run this to get put spread with break @ the money
putSpread <- function(theOptionList){
print(theOptionList$PutOutOfTheMoney)
print("------------------------------------------------------------")
print(theOptionList$PutInTheMoney)
}
x11()
chartSeries(SPY)
addBBands()
addMACD()
addRSI()
addExpiry()
SPYOption <- OptionChain(SPY)
SPYOption$PutToCallRatioVol
SPYOption$PutToCallRatioOI
callSpread(SPYOption)
putSpread(SPYOption)
source('E:/Shared_Files/Fchang012/Diamond_Analysis/HTML_Table_Parse.R', echo=TRUE)
BlueNileTable <- xmlTreeParse(BlueNileTable)[[1]]
top <- xmlRoot(BlueNileTable)
headers <- getNodeSet(top, '//div[@class="row"]')
headers <- getNodeSet(headers[[1]], '//div')
headers <- headers[-1]
headerList <- list()
for(i in 1:length(headers)){
headerList[i] <- xmlValue(headers[[i]])
}
eachRecord <- getNodeSet(top, '//a')
blueNileDataframe <- xmlToDataFrame(nodes = eachRecord, stringsAsFactors = FALSE)
urlList <- list()
for(i in 1:length(eachRecord)){
urlList[i] <- paste('https://www.bluenile.com', substring((xmlGetAttr(eachRecord[[i]], 'href')),2), sep = '')
}
urlList <- t(as.data.frame(urlList, stringsAsFactors = FALSE))
top
?getNodeSet
names(blueNileDataframe) <- headerList
blueNileDataframe <- cbind(blueNileDataframe, urlList)
rownames(blueNileDataframe) <- NULL
blueNileDataframe <- as.tibble(blueNileDataframe)
# Fix price into a numeric
blueNileDataframe$Price <- as.numeric(gsub('[$,]', '', blueNileDataframe$Price))
JamesAllenTable <- readHTMLTable("./RAW/JamesAllenWebTable.txt", stringsAsFactors = FALSE)
JamesAllenTable <- list.clean(JamesAllenTable, fun = is.null, recursive = FALSE)
JamesAllenTable <- as.tibble(JamesAllenTable$ResultsTable[,1:11])
JamesAllenIDs <- htmlTreeParse("./RAW/JamesAllenWebTable.txt")[[1]]
idList <- list()
JamesAllenIDs <- getNodeSet(JamesAllenIDs, '//tr[@data-item-id]')
for(i in 1:length(JamesAllenIDs)){
idList[i] <- paste('https://www.jamesallen.com/ese/?q=', xmlAttrs(JamesAllenIDs[[i]])[[5]], sep = '')
}
idList <- t(as.data.frame(idList, stringsAsFactors = FALSE))
rownames(idList) <- NULL
colnames(idList) <- "urlList"
JamesAllenTable <- cbind(JamesAllenTable, idList)
JamesAllenTable <- as.tibble(JamesAllenTable)
colnames(JamesAllenTable) <- make.names(colnames(JamesAllenTable))
colnames(JamesAllenTable) <- gsub('[X.]', '', colnames(JamesAllenTable))
# Fix price as numeric
JamesAllenTable$Price <- as.numeric(gsub('[$,]', '', JamesAllenTable$Price))
View(blueNileDataframe)
source('E:/Shared_Files/Fchang012/Diamond_Analysis/HTML_Table_Parse.R', echo=TRUE)
source('E:/Shared_Files/Fchang012/Diamond_Analysis/HTML_Table_Parse.R', echo=TRUE)
BlueNileTable <- read_xml("./RAW/BlueNileTable.html", as_html = T)
BlueNileTable <- xmlTreeParse(BlueNileTable)[[1]]
top <- xmlRoot(BlueNileTable)
# headers
headers <- getNodeSet(top, '//div[@class="row"]')
headers <- getNodeSet(headers[[1]], '//div')
headers <- headers[-1]
headerList <- list()
for(i in 1:length(headers)){
headerList[i] <- xmlValue(headers[[i]])
}
# each records
eachRecord <- getNodeSet(top, '//a')
blueNileDataframe <- xmlToDataFrame(nodes = eachRecord, stringsAsFactors = FALSE)
urlList <- list()
for(i in 1:length(eachRecord)){
urlList[i] <- paste('https://www.bluenile.com', substring((xmlGetAttr(eachRecord[[i]], 'href')),2), sep = '')
}
urlList <- t(as.data.frame(urlList, stringsAsFactors = FALSE))
# Create df
names(blueNileDataframe) <- headerList
blueNileDataframe <- cbind(blueNileDataframe, urlList)
rownames(blueNileDataframe) <- NULL
blueNileDataframe <- as.tibble(blueNileDataframe)
# Fix price into a numeric
blueNileDataframe$Price <- as.numeric(gsub('[$,]', '', blueNileDataframe$Price))
JamesAllenTable <- readHTMLTable("./RAW/JamesAllenWebTable.txt", stringsAsFactors = FALSE)
JamesAllenTable <- list.clean(JamesAllenTable, fun = is.null, recursive = FALSE)
JamesAllenTable <- as.tibble(JamesAllenTable$ResultsTable[,1:11])
# Getting the ids
JamesAllenIDs <- htmlTreeParse("./RAW/JamesAllenWebTable.txt")[[1]]
idList <- list()
JamesAllenIDs <- getNodeSet(JamesAllenIDs, '//tr[@data-item-id]')
for(i in 1:length(JamesAllenIDs)){
idList[i] <- paste('https://www.jamesallen.com/ese/?q=', xmlAttrs(JamesAllenIDs[[i]])[[5]], sep = '')
}
idList <- t(as.data.frame(idList, stringsAsFactors = FALSE))
rownames(idList) <- NULL
colnames(idList) <- "urlList"
JamesAllenTable <- cbind(JamesAllenTable, idList)
JamesAllenTable <- as.tibble(JamesAllenTable)
colnames(JamesAllenTable) <- make.names(colnames(JamesAllenTable))
colnames(JamesAllenTable) <- gsub('[X.]', '', colnames(JamesAllenTable))
# Fix price as numeric
JamesAllenTable$Price <- as.numeric(gsub('[$,]', '', JamesAllenTable$Price))
# Remove IGI Lab results
JamesAllenTable <- JamesAllenTable[JamesAllenTable$Lab != "IGI",]
reqd <- as.vector(c("Price", "Carat", "Cut", "Color", "Clarity", "urlList"))
FinalDF <- blueNileDataframe[,reqd]
View(FinalDF)
FinalDF[FinalDF$Cut == "GoodGood",]$Cut <- "Good"
FinalDF[FinalDF$Cut == "Very GoodVery Good",]$Cut <- "Very Good"
FinalDF[FinalDF$Cut == "Astor IdealAstor",]$Cut <- "Astor Ideal"
FinalDF[FinalDF$Cut == "Astor IdealAstor",]$Cut
reqd <- as.vector(c("Price", "Carat", "Cut", "Color", "Clarity", "urlList"))
FinalDF <- blueNileDataframe[,reqd]
FinalDF[FinalDF$Cut == "GoodGood",]$Cut
FinalDF$Cut
unique(FinalDF$Cut)
# Fixing cuts for bluenile
FinalDF[FinalDF$Cut == "GoodGood",]$Cut <- "Good"
FinalDF[FinalDF$Cut == "Very GoodVery Good",]$Cut <- "Very Good"
FinalDF[FinalDF$Cut == "Astor IdealAstor",]$Cut <- "Astor Ideal"
FinalDF[FinalDF$Cut == "IdealIdeal",]$Cut <- "Ideal"
View(FinalDF)
tempJamesAllenDF <- JamesAllenTable[, reqd]
FinalDF <- rbind(FinalDF, tempJamesAllenDF)
FinalDF$Carat <- as.numeric(FinalDF$Carat)
View(tempJamesAllenDF)
source('E:/Shared_Files/Fchang012/Diamond_Analysis/HTML_Table_Parse.R', echo=TRUE)
source('E:/Shared_Files/Fchang012/Diamond_Analysis/HTML_Table_Parse.R', echo=TRUE)
# Blue Nile ---------------------------------------------------------------
BlueNileTable <- read_xml("./RAW/BlueNileTable.html", as_html = T)
BlueNileTable <- xmlTreeParse(BlueNileTable)[[1]]
top <- xmlRoot(BlueNileTable)
# headers
headers <- getNodeSet(top, '//div[@class="row"]')
headers <- getNodeSet(headers[[1]], '//div')
headers <- headers[-1]
headerList <- list()
for(i in 1:length(headers)){
headerList[i] <- xmlValue(headers[[i]])
}
# each records
eachRecord <- getNodeSet(top, '//a')
blueNileDataframe <- xmlToDataFrame(nodes = eachRecord, stringsAsFactors = FALSE)
urlList <- list()
for(i in 1:length(eachRecord)){
urlList[i] <- paste('https://www.bluenile.com', substring((xmlGetAttr(eachRecord[[i]], 'href')),2), sep = '')
}
urlList <- t(as.data.frame(urlList, stringsAsFactors = FALSE))
# Create df
names(blueNileDataframe) <- headerList
blueNileDataframe <- cbind(blueNileDataframe, urlList)
rownames(blueNileDataframe) <- NULL
blueNileDataframe <- as.tibble(blueNileDataframe)
# Fix price into a numeric
blueNileDataframe$Price <- as.numeric(gsub('[$,]', '', blueNileDataframe$Price))
# James Allen -------------------------------------------------------------
JamesAllenTable <- readHTMLTable("./RAW/JamesAllenWebTable.txt", stringsAsFactors = FALSE)
JamesAllenTable <- list.clean(JamesAllenTable, fun = is.null, recursive = FALSE)
JamesAllenTable <- as.tibble(JamesAllenTable$ResultsTable[,1:11])
# Getting the ids
JamesAllenIDs <- htmlTreeParse("./RAW/JamesAllenWebTable.txt")[[1]]
idList <- list()
JamesAllenIDs <- getNodeSet(JamesAllenIDs, '//tr[@data-item-id]')
for(i in 1:length(JamesAllenIDs)){
idList[i] <- paste('https://www.jamesallen.com/ese/?q=', xmlAttrs(JamesAllenIDs[[i]])[[5]], sep = '')
}
idList <- t(as.data.frame(idList, stringsAsFactors = FALSE))
rownames(idList) <- NULL
colnames(idList) <- "urlList"
JamesAllenTable <- cbind(JamesAllenTable, idList)
JamesAllenTable <- as.tibble(JamesAllenTable)
colnames(JamesAllenTable) <- make.names(colnames(JamesAllenTable))
colnames(JamesAllenTable) <- gsub('[X.]', '', colnames(JamesAllenTable))
# Fix price as numeric
JamesAllenTable$Price <- as.numeric(gsub('[$,]', '', JamesAllenTable$Price))
# Remove IGI Lab results
JamesAllenTable <- JamesAllenTable[JamesAllenTable$Lab != "IGI",]
reqd <- as.vector(c("Price", "Carat", "Cut", "Color", "Clarity", "urlList"))
FinalDF <- blueNileDataframe[,reqd]
FinalDF[FinalDF$Cut == "GoodGood",]$Cut <- "Good"
FinalDF[FinalDF$Cut == "Very GoodVery Good",]$Cut <- "Very Good"
FinalDF[FinalDF$Cut == "Astor IdealAstor",]$Cut <- "Astor Ideal"
FinalDF[FinalDF$Cut == "IdealIdeal",]$Cut <- "Ideal"
tempJamesAllenDF <- JamesAllenTable[, reqd]
FinalDF <- rbind(FinalDF, tempJamesAllenDF)
FinalDF$Carat <- as.numeric(FinalDF$Carat)
write.table(FinalDF, "./Clean_Data/Diamond_Data.csv", sep = rawToChar(as.raw(127)))
View(FinalDF)
this.dir <- dirname(parent.frame(2)$ofile)
source('E:/Shared_Files/Fchang012/Diamond_Analysis/Diamond_Analysis.R', echo=TRUE)
FinalDF$Cut <- factor(FinalDF$Cut, levels(FinalDF$Cut)[c(1,5,2,4,6,3)])
FinalDF$Clarity <- factor(FinalDF$Clarity, levels(FinalDF$Clarity)[c(1,6,7,4,5,2,3)])
# Plots
# Cut
ggplot(FinalDF,
aes(x=Carat,
y=Price)) +
geom_point(aes(shape=Cut, color=Cut)) +
ggtitle("Caret vs Price With Cut As Legend") +
theme_bw()
# Color
ggplot(FinalDF,
aes(x=Carat,
y=Price)) +
geom_point(aes(shape=Color, color=Color)) +
ggtitle("Caret vs Price With Color As Legend") +
theme_bw()
# Clarity
ggplot(FinalDF,
aes(x=Carat,
y=Price)) +
geom_point(aes(shape=Clarity, color=Clarity)) +
ggtitle("Caret vs Price With Clarity As Legend") +
theme_bw()
x11()
ggplot(FinalDF,
aes(x=Carat,
y=Price)) +
geom_point(aes(shape=Cut, color=Cut)) +
ggtitle("Caret vs Price With Cut As Legend") +
theme_bw()
# Color
ggplot(FinalDF,
aes(x=Carat,
y=Price)) +
geom_point(aes(shape=Color, color=Color)) +
ggtitle("Caret vs Price With Color As Legend") +
theme_bw()
x11()
ggplot(FinalDF,
aes(x=Carat,
y=Price)) +
geom_point(aes(shape=Color, color=Color)) +
ggtitle("Caret vs Price With Color As Legend") +
theme_bw()
tempDF <- as.tibble(cbind(model.matrix( ~ Cut - 1, data=FinalDF), model.matrix( ~ Color - 1, data=FinalDF), model.matrix( ~ Clarity - 1, data=FinalDF)))
FinalDF <- as.tibble(cbind(FinalDF, tempDF))
colnames(FinalDF) <- make.names(colnames(FinalDF))
fString <- paste('log(Price) ~ log(Carat)+', paste(colnames(FinalDF)[-c(1:6, 12, 20, 27)], collapse = '+'), sep = '')
fit <- lm(fString, data=FinalDF)
summary(fit)
linDependTerm <- alias(fit)
coeff=coefficients(fit)
x11()
ggplot(FinalDF, aes(x=Carat,
y=Price,
color=Cut)) +
geom_point() +
stat_smooth(method = "lm", col = "red")
FinalDF <- cbind(FinalDF, Forecast=exp(predict(fit)))
FinalDF <- cbind(FinalDF, Residual=resid(fit))
focus <- FinalDF[FinalDF$Residual <= quantile(FinalDF$Residual, 0.1), ]
View(focus)
focus <-focus[(focus$CutAstor.Ideal == 1 | focus$CutIdeal == 1), ]
ggplot(focus,
aes(x=Carat,
y=Price,
color=Cut)) +
geom_point(aes(shape=Cut, color=Cut)) +
ggtitle("Top 1% Cut") +
theme_bw()
ggplot(focus,
aes(x=Carat,
y=Price,
color=Color)) +
geom_point(aes(shape=Color, color=Color)) +
ggtitle("Top 1% Color") +
theme_bw()
ggplot(focus,
aes(x=Carat,
y=Price,
color=Clarity)) +
geom_point(aes(shape=Clarity, color=Clarity)) +
ggtitle("Top 1% Clarity") +
theme_bw()
write.table(focus[,c(1:6,28:29)], "./Output/focus.csv", sep = ",", row.names = FALSE)
require(ggplot2)
require(corrplot)
require(tibble)
require(dplyr)
# Some basic analysis on diamond prices based on https://github.com/amarder/diamonds/blob/master/diamonds.Rmd
# Get cur dir from source of R Script
this.dir <- dirname(parent.frame(2)$ofile)
setwd(this.dir)
# Import Data
FinalDF <- read.csv("./Clean_Data/Diamond_Data.csv", sep = rawToChar(as.raw(127)))
# Reorder Factor Levels
FinalDF$Cut <- factor(FinalDF$Cut, levels(FinalDF$Cut)[c(1,5,2,4,6,3)])
FinalDF$Clarity <- factor(FinalDF$Clarity, levels(FinalDF$Clarity)[c(1,6,7,4,5,2,3)])
## Plot of Caret vs Price and Amarder Analysis --------------------------------------------------------
# Plots
# Cut
ggplot(FinalDF,
aes(x=Carat,
y=Price)) +
geom_point(aes(shape=Cut, color=Cut)) +
ggtitle("Caret vs Price With Cut As Legend") +
theme_bw()
# Color
ggplot(FinalDF,
aes(x=Carat,
y=Price)) +
geom_point(aes(shape=Color, color=Color)) +
ggtitle("Caret vs Price With Color As Legend") +
theme_bw()
# Clarity
ggplot(FinalDF,
aes(x=Carat,
y=Price)) +
geom_point(aes(shape=Clarity, color=Clarity)) +
ggtitle("Caret vs Price With Clarity As Legend") +
theme_bw()
## Blue Nileâs buying guide describes how the four Câs (cut, color, clarity, and carat weight) are the most
## important characteristics when buying a diamond. It seems reasonable to model price as a function of those
## four characteristics. Having played around with the data bit, a multiplicative model seems like a good choice.
## I model price as a product of carat weight raised to the power Î² times multipliers for the cut, color, and
## clarity of the diamond.
##
## PriceiâcaratÎ²i â cuti â colori â clarityi
##
## Taking logâs of both sides allows this model to be estimated using a linear regression
##
## log(pricei)=Î±+Î²log(carati)+Î´cuti+Î´colori+Î´clarityi+Ïµi
# Create dummy var for Cut, Color, Clarity and disregard the CutGood, ColorG, and ClarityVS2 as they are dependent on the other respective variables
tempDF <- as.tibble(cbind(model.matrix( ~ Cut - 1, data=FinalDF), model.matrix( ~ Color - 1, data=FinalDF), model.matrix( ~ Clarity - 1, data=FinalDF)))
FinalDF <- as.tibble(cbind(FinalDF, tempDF))
colnames(FinalDF) <- make.names(colnames(FinalDF))
fString <- paste('log(Price) ~ log(Carat)+', paste(colnames(FinalDF)[-c(1:6, 12, 20, 27)], collapse = '+'), sep = '')
fit <- lm(fString, data=FinalDF)
# Summary of fit
summary(fit)
# Correlation
linDependTerm <- alias(fit)
# Find the coeff of fit and use it to plot fitted line
# https://www.statmethods.net/stats/regression.html for more documentation on Fitting lm
coeff=coefficients(fit)
# PLotting regression line
ggplot(FinalDF, aes(x=Carat,
y=Price,
color=Cut)) +
geom_point() +
stat_smooth(method = "lm", col = "red")
# Adding in the regression forecasts back into df
FinalDF <- cbind(FinalDF, Forecast=exp(predict(fit)))
FinalDF <- cbind(FinalDF, Residual=resid(fit))
# Top 1% with least residuals
focus <- FinalDF[FinalDF$Residual <= quantile(FinalDF$Residual, 0.1), ]
# Only ideal + cuts
focus <-focus[(focus$CutAstor.Ideal == 1 | focus$CutIdeal == 1), ]
# Plot of Top 1%
ggplot(focus,
aes(x=Carat,
y=Price,
color=Cut)) +
geom_point(aes(shape=Cut, color=Cut)) +
ggtitle("Top 1% Cut") +
theme_bw()
ggplot(focus,
aes(x=Carat,
y=Price,
color=Color)) +
geom_point(aes(shape=Color, color=Color)) +
ggtitle("Top 1% Color") +
theme_bw()
ggplot(focus,
aes(x=Carat,
y=Price,
color=Clarity)) +
geom_point(aes(shape=Clarity, color=Clarity)) +
ggtitle("Top 1% Clarity") +
theme_bw()
# Write to table to explore
write.table(focus[,c(1:6,28:29)], "./Output/focus.csv", sep = ",", row.names = FALSE)
View(focus)
write.table(focus[,c(1:6,27:28)], "./Output/focus.csv", sep = ",", row.names = FALSE)
